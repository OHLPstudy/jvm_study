**⏳ Timeline 3 — 객체는 어떻게 태어나고 죽는가**

**객체 생명주기**

```
new → Eden
    → Survivor
    → Old Generation
    → GC 대상

```

**GC Root 개념의 등장**

GC는 **Root에서 도달 가능한 객체만 생존**

**주요 GC Root**

- Thread Stack
- Local Variable
- Static Field
- JNI Reference

📌 **Dump 분석의 본질**

> "이 객체를 누가 붙잡고 있는가?"
> 

---

# Tip

```jsx
GC의 수거 대상은 Heap 영역입니다. 그러므로 Heap 영역의 리소스를 효율적으로 제거하기 위한 방법이 
있어야합니다,
```

# Class Loader

```
컴파일 된 자바의클래스 파일(*.class)을 동적으로 로드하고, JVM의 메모리 영역인 Runtime Data Areas에 배치하는 작업을 수행한다.
따라서 Class는 어플리케이션이 실행될 때 전부 로드되는 것이 아님

```

### 클래스 로더를 통해 클래스가 로드되는 케이스

1. 생성자를 통한 인스턴스 생성
2. static 필드 사용
    1. static final 객체 사용 시에는 클래스 로드되지않음
        1. 해당 static final 객체는 Method area인 Constant Pool에서 관리하기 떄문

출처: [https://inpa.tistory.com/entry/JAVA-☕-클래스는-언제-메모리에-로딩-초기화-되는가-❓](https://inpa.tistory.com/entry/JAVA-%E2%98%95-%ED%81%B4%EB%9E%98%EC%8A%A4%EB%8A%94-%EC%96%B8%EC%A0%9C-%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%97%90-%EB%A1%9C%EB%94%A9-%EC%B4%88%EA%B8%B0%ED%99%94-%EB%90%98%EB%8A%94%EA%B0%80-%E2%9D%93)

# GC Root

**자바(JVM)의 가비지 컬렉터(GC)가 메모리 해제 대상을 식별하기 위해 사용하는 도달 가능성(Reachability)의 시작점**

- 쉽게 말해서 GC 작업을 진행할때 정리가 되면 안되는 대상들을 식별을 판단하기 위한 역할
- GC Root가 제거된다면 GC 대상으로 식별됨

example

```jsx
public static void main(String[] args) {
        foo();
        System.gc();
				say();
    }
   static void says(){
		   C c =  new C();
   }
    static void foo() {
        A a = new A();
        bar(a);
    }

    static void bar(A param) {
        B b = new B();
        // 여기서 GC가 발생한다고 가정한다.
    }
  }
```

- System.gc() 호출이 된다면 Static Reference 영역(GC ROOT)인 a,b 객체는 인스턴스는 제거됨
    - foo(), bar() 메소드가 종료되어 a, b의 참조값이 Static Reference가 제거되었기 떄문에 제거되는 것임

## GC Root가 될 수 있는 영역

- 실행중인 쓰레드 (Active Thread)
- 정적 변수 (Static Variable)
- 로컬 변수 (Local Variable)
- JNI 레퍼런스 (JNI Reference)

## Active Thread

실행중인 스레드가 GC의 대상이 된다면 스레드에서 이뤄져야 할 작업이 완료가 불가해짐

### 언제 수거되는가?

- Thread.join() (종료상태) 가 될떄

### Thread Pool 사용 시 Thread 는 GC 의 대상이 될 수 있습니까?

- ㄴㄴ 계속 Alive라 대상이 될 수 없음

## Static Variable

static 변수가 GC 수거 대상이 된다면 객체에서 static 변수 데이터를 활용할 수 없음

### 언제 수거되는가 ?

해당 Static 변수를 사용하는 MetaSpace에 저장되는 클래스가  제거되면 수거됨

- MetaSpace에 저장된 클래스정보는 ClassLoader가 GC 대상이 되면 수거됨 ㅋㅋ;;
    - 참고로 ClassLoader 또한 인스턴스로 Heap 영역에 저장됨

https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html

### 클래스 로더

```jsx
그렇다면 Static Variable가 참조하는 다른 "ROOT" 가 있다고 생각됩니다.
그렇다면 GC ROOT의 대상은 Static Variable이 아닌 MetaSpace 영역이 GC ROOT가
되어야 하지 않습니까?
```

- MetaSpace는 Heap 영역과 직접적으로 연결이 되는 영역이 아니며, Heap 영역 수거를 위해 MetaSpace 영역을 GC Root로 잡을 필요는 없음.

## Local Variable

로컬변수가 필요할떈 GC의 대상이 안됨

### 언제 수거되는가?

로컬 변수는 해당 로컬변수가 생성된 메서드가 종료될 때 스택프레임이 제거되어 GC의 대상이 될수 있음

## JNI Reference

C, C++로 구현된 Native Interface는 사용중일 때 GC의 대상이 되어선 안됩니다.

### 언제 수거되는가?

JNI객체에서 DeleteGlobalRef가 호출될 때 수거됨

그리고 그 이후에 다른 GC Root에서 참조되지 않아야 함

https://www.ibm.com/docs/en/sdk-java-technology/8?topic=jni-garbage-collector&utm_source=chatgpt.com
