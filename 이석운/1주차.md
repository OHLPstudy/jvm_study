# TimeLine 0

## OOM 발생이유

- 설정된 메모리보다 사용해야 할 메모리가 많으면 발생함

## Heap 영역에서만 OOM이 발생하나?

MetaSpace OOM도 존재한

### OOM 종류

**Java Heap Space**

[**GC Overhead limit exceeded**](https://mjoo1106.tistory.com/entry/GC-Overhead-limit-exceeded-%EB%A1%9C-%EC%8B%9C%EC%9E%91%ED%95%98%EC%97%AC-JVM-%EC%83%9D%EB%9E%B5)

- 전체 실행시간의 98% 이상을 GC에 사용하거나, 전체 힙 메모리가 2% 미만으로 확보되는 현상이 5회 반복되면 발생
    - https://docs.oracle.com/javase/8/docs/technotes/guides/troubleshoot/memleaks002.html

**MetaSpace**

- 새로운 클래스를 저장할 MetaSpace 공간이 부족할 때 발생

MetaSpace 란?

- 클래스 메타데이터를 저장하는데 사용하는 Native 영역의 메모리
- 클래스에 대한 설명(메타정보)을 담고있음

**Requested array size exceeds VM Limit**

- VM의 제한보다 큰 배열을 생성하려는 시도가 발생
- Array Max Length는 공개되진 않았음
    - https://bugs.openjdk.org/browse/JDK-8246725?utm_source=chatgpt.com

## Gc Pause Time

- STW 발생으로 어플리케이션이 멈추는 시간을 의미
    - 이 시간을 줄이기 위해 여러 GC 알고리즘이 생겨나고 있음

# Timeline 1

## 수동 메모리 관리

C언어에서는 메모리 관리를 개발자가 수동으로 진행해주어야 했음

```jsx
#include <stdio.h>
#include <stdlib.h>
 
int main() {        
    char *c = (char*)malloc(1); //1바이트 메모리 할당
    *c = 'h';
    printf("%d, %c\n",c, *c);//c의 주소값, c의 값 'h'
    free(c); //메모리 해제
}
```

- 만약 c 변수에 대한 free 선언이 없다면 c 변수는 메모리 공간에 계속 남아있음 (메모리 누수)

이러한 수동 메모리 관리가 귀찮아서 생겨난게 JVM 의 **Garbage Collector** 

- 메모리 관리를 개발자에게 맡기면 휴먼에러 발생 확률이 굉장히 높고 이것은 시스템 리소스 낭비로 직접적으로 이어짐

### Garbage Collector

```
Heap 영역에서동적으로 할당했던 메모리 중 필요 없게 된 메모리 객체(garbage)를 모아 주기적으로 제거하는 프로세스
```

https://inpa.tistory.com/entry/JAVA-%E2%98%95-%EA%B0%80%EB%B9%84%EC%A7%80-%EC%BB%AC%EB%A0%89%EC%85%98GC-%EB%8F%99%EC%9E%91-%EC%9B%90%EB%A6%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%F0%9F%92%AF-%EC%B4%9D%EC%A0%95%EB%A6%AC#garbage_collectiongc_%EC%9D%B4%EB%9E%80?

## JVM 의 Goal

- Write Once, Run Anywhere
- 안전한 실행 환경
- 자동 메모리 관리

## 문제점

> JVM은 메모리를 대신 관리한다 → 우리는 그 "관리 결과"를 해석해야 한다.
> 

```jsx
PS E:\gitPrjxt\goj> java -verbose:gc .\NestedSample.java
[0.013s][info][gc] Using G1
[0.033s][info][gc] Periodic GC disabled
[0.450s][info][gc] GC(0) Pause Young (Normal) (G1 Evacuation Pause) 23M->2M(250M) 2.957ms
[0.512s][info][gc] GC(1) Pause Young (Normal) (G1 Evacuation Pause) 149M->2M(250M) 2.084ms
[0.529s][info][gc] GC(2) Pause Young (Normal) (G1 Evacuation Pause) 149M->2M(250M) 2.278ms
10000
```

- JVM이 대신 관리해주는 순간 얘가 왜 이렇게 행동하였는지 분석해야 함
    - OOM같은 메모리 관리에 문제가 생겼을 땐 JVM 행동 결과에 대한 원인분석이 필요하다는 소리
