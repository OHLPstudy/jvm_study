## ⏳ Timeline 2 — 초기 JVM 메모리 구조의 탄생

### Runtime Data Areas

```
Method Area (→ Metaspace)
Heap
 ├─ Young
 └─ Old
Thread Stack
Native Area

```

### 왜 이렇게 나뉘었는가?

- Stack: 빠른 실행, 스레드 독립성
- Heap: 객체 공유
- Method Area: 클래스 메타데이터

📌 **Dump 분석 핵심 포인트**

- Heap Dump는 Heap만 보여준다
- Metaspace OOM은 Heap Dump로 해결 안 됨

## Stack

메소드 내에서 정의하는  기본자료형(Primitive Type - int, double, byte…)에 해당되는 지역변수, 매개변수의 데이터값이 저장되는 공간

각 스레드마다 독립적인 공간

메소드가 실행될때 Stack 영역 안에 스택 프레임이 생기고 Stack 영역안의 메소드 호출

메소드가 호출될때 메모리 할당 → 메서드가 종료 되면 메모리에서 사라짐

### Stack Frame

하나의 메서드에 필요한 메모리 덩어리를 묶어서 스택프레임이라고 함

하나의 메서드당 하나의 스택프레임이 필요함

메서드를 호출하기 직전 스택 프레임을 스택 영역에 생성한 후 메소드를 호출하고,
쌓이는 데이터는 매개변수, 지역변수, 리턴값이 있음

메서드가 종료되면 제거

<img width="1280" height="1684" alt="image" src="https://github.com/user-attachments/assets/6ee29c42-4f1d-4231-8ab9-efc5d7d63c7b" />


```
참고로 Car 생성자 스택 프레임에 저장된 name과 position은 인스턴스 필드가 아니라 파라미터 데이터가 저장된 것이다.

```

- 위의 그림같은 Stack영역 구조때문에 메소드별 지역변수 기본자료형의 값이 공유되지 않는 것임
    - 각 메소드 별 스택프레임이 독립적이기 때문

### 스택프레임에 저장된 파라미터와 전역변수 (position…)의 메모리주소는 같은가?

다름 그리고 Java는 Call By Value 임

```jsx
Heap
 └─ String 객체 ("BMW")
 └─ Car 객체
     ├─ name ──► String 객체
     └─ value = 10

Stack
 └─ world frame
     └─ this ──► Car 객체

 └─ move frame
     ├─ name  ──► String 객체  (참조 복사)
     └─ value = 10             (값 복사)

```

value는 10이라는 값이 복사되므로 move 프레임영역에서 값이 변경되어도 Stack move frame에서만 변경
됨 (메소드 종료 시 삭제되는 값들임)

String은 참조 값이지만 불변객체라 값이 변경 될 경우 새로운 참조값으로 객체가 생성됨 

- 그러므로 Stack Frame 영역에 독립적임

## Heap

객체의 인스턴스와 배열이 생성되는 공간

Heap 영역은 공유 됨

Heap 영역의 인스턴스는 자신의 클래스에 대한 메타데이터(StackFrame)을 공유 받는다

<img width="1280" height="912" alt="image" src="https://github.com/user-attachments/assets/822f5e5a-636e-47b5-96aa-24d51f217f52" />


## Method Area

클래스가 로딩 될 때 생성 (런타임 시점)

클래스 변수(Static 변수), 생성자와 매소드를 저장하는 공간

모든 스레드 공유

어플리케이션이 종료되기 전 까지 저장 되있으므로 과하지 않게 사용해야 함

### Method 영역 예시

Car Class

```jsx
public class Car {
    private static final int NAME_LENGTH_COND = 5; //Method 영역(Static)
 
    private final String name;
    private int position;
 
    public Car(final String name, final int position) { // Method 영역(Method)
		    validateNameLength(name);
        this.name = name;
        this.position = position;
    }
 
    public void move() { // Method 영역(Method)
        position++;
    }
 
    private void validateNameLength(final String name) { // Method 영역(Method)
        if (name.length() > NAME_LENGTH_COND) {
            throw new IllegalArgumentException("이름은 5글자까지만 가능합니다.");
        }
    }
}
```

## 영역이 나눠진 이유

궁극적 목표는 리소스 절약임

### static 변수는 인스턴스 수준에 종속되지 않음

한마디로 Heap 영역에 생성되는 인스턴스들 별로 static 변수의 값을 저장하지 않는다는 것임

그러한 공통적 Value를 Heap 영역 인스턴스 생성마다 값을 가지고 있을 필요가 없음

→ Method 영역에서 관리하고 Heap 영역에선 필요할때마다 끌어와서 쓰면 됨

### 

## Young, Old 영역은 왜 나누어졌는가?

### 약한 세대 가설(Weak Generational Hypothesis)

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2FIXvnf%2Fbtq9OGMjV6z%2FAAAAAAAAAAAAAAAAAAAAAEPFAdm2yxfxXf8EGEt5iE56hjeVSXbmxvmdeZHsqJ9x%2Fimg.png%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1769871599%26allow_ip%3D%26allow_referer%3D%26signature%3DRM%252BwrVKbXVk6qoS90WM7ul4tuSk%253D)
대다수의 객체는 짧은시간 동안만 살아있음

- 그렇다면 모든 객체를 같은 라이프사이클방식으로 메모리에 저장하는 건 비효율적임
    - 자주 사용되는 객체와, 금방 제거되는 객체를 구분짓기 위해서 영역을 분리

## C언어와 다른 점

C언어는 Memory Free (메모리에서 객체 제거) 작업을 개발자가 수동으로 해야 함

GC가 갖는 오버헤드를 감당할 수 있는 어플리케이션이라면 GC같은 외부 가비지 컬렉터를 채택하는 게 

휴먼에러도 줄일 수 있음 ㅋ

## JIT(JustInTime)컴파일러

<img width="1280" height="530" alt="image" src="https://github.com/user-attachments/assets/ef77f90e-eb8f-4a72-87b4-2a7c86f62818" />


JAVA는 자바 컴파일러를 이용해 바이트코드로 컴파일 한다

- 그러므로 OS에 종속되지 않을 수 있음

런타임 시점에 바이트코드를 기계어로 번역합니다.

- 하지만 모든 바이트코드를 런타임 시점에 기계어로 해석한다면 속도에 문제가 생길 수 밖에 없음

JIT 컴파일러과 Hotspot JVM 관련 설명은 여기서 자세히 볼 수 있음

https://github.com/OHLPstudy/jvm_study/issues/3
